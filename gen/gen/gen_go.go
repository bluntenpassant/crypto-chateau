package gen

import (
	"fmt"
	"go/format"
	"strconv"
	"unicode"

	"github.com/pkg/errors"

	ast2 "github.com/oringik/crypto-chateau/gen/ast"
	"github.com/oringik/crypto-chateau/gen/templates"
	"github.com/oringik/crypto-chateau/version"
)

var result string
var ast *ast2.Ast

func GenerateDefinitions(astLocal *ast2.Ast) string {
	ast = astLocal

	fillVersion()
	fillPackage()
	fillImports()
	fillTagsByHandlerName()
	fillServices()
	fillHandlerHashMap()
	fillSqueezes()
	err := fillObjects()
	if err != nil {
		panic("objects generation failed:" + err.Error())
	}
	fillGetHandlers()
	fillEmptyGetHandlers()
	fillNewServer()
	fillCallClientMethod()

	fillClients()

	resultRaw, err := format.Source([]byte(result))
	if err != nil {
		panic("formatting failed:" + err.Error())
	}

	result = string(resultRaw)

	return result
}

func fillImports() {
	result += `
		import (
			"context"
			"net"
			"strconv"
		
			"github.com/pkg/errors"
			"go.uber.org/zap"
		
			"github.com/oringik/crypto-chateau/gen/conv"
			"github.com/oringik/crypto-chateau/gen/hash"
			"github.com/oringik/crypto-chateau/message"
			"github.com/oringik/crypto-chateau/peer"
			"github.com/oringik/crypto-chateau/server"
			"github.com/oringik/crypto-chateau/transport/multiplex_conn"
			"github.com/oringik/crypto-chateau/transport/handshake"
		)
`

}

func fillPackage() {
	result += "package " + ast.Chateau.PackageName + "\n\n"
}

func fillVersion() {
	result += "// Code generated by crypto-chateau " + version.CodegenVersion + " DO NOT EDIT.\n\n"
}

func fillClients() {
	for _, service := range ast.Chateau.Services {
		result += "type Client" + service.Name + " struct {\n"
		result += "\tmultiplexConnPool *multiplex_conn.MultiplexConnPool\n"
		result += "}\n\n"

		result += "func NewClient" + service.Name + "(host string, port int) (*Client" + service.Name + ", error) {\n"
		result += "\tconn, err := net.Dial(\"tcp\", host + \":\" + strconv.Itoa(port))\n"
		result += "\tif err != nil{\n"
		result += "\t\treturn nil, err\n"
		result += "\t}\n"
		result += "\tconn, err = handshake.ServerHandshake(conn)\n"
		result += "\tif err != nil{\n"
		result += "\t\treturn nil, err\n"
		result += "\t}\n"
		result += "multiplexConnPool := multiplex_conn.NewMultiplexConnPool(conn, true)\n"
		result += "multiplexConnPool.Run()\n"
		result += "client := &Client" + service.Name + "{multiplexConnPool: multiplexConnPool}\n"
		result += "return client, nil\n"
		result += "}\n\n"
		for _, method := range service.Methods {
			result += "func (c *Client" + service.Name + ") " + method.Name + "(ctx context.Context, "
			for i, param := range method.Params {
				result += param.Name + " "
				if param.Type.IsArray {
					result += "["
					if param.Type.ArrSize != 0 {
						result += strconv.Itoa(param.Type.ArrSize)
					}
					result += "]"
				}

				if param.Type.Type == ast2.Object {
					result += "*" + param.Type.ObjectName
				} else {
					result += ast2.AstTypeToGoType[param.Type.Type]
				}
				if i != len(method.Params)-1 {
					result += ", "
				}
			}
			result += ") "
			if method.MethodType != ast2.Stream {
				result += "("
				for i, ret := range method.Returns {
					if ret.Type.IsArray {
						result += "["
						if ret.Type.ArrSize != 0 {
							result += strconv.Itoa(ret.Type.ArrSize)
						}
						result += "]"
					}

					if ret.Type.Type == ast2.Object {
						result += "*" + ret.Type.ObjectName
					} else {
						result += ast2.AstTypeToGoType[ret.Type.Type]
					}
					if i != len(method.Returns)-1 {
						result += ", "
					}
				}
				result += ", "
			} else {
				result += "(*peer.Peer,"
			}
			result += "error)"
			result += "{\n"
			result += "multiplexConn := c.multiplexConnPool.NewMultiplexConn()\n"
			result += "peer := peer.NewPeer(multiplexConn)\n"
			result += "\terr := peer.SendRequestClient(" + "hash.HandlerHash{" + method.Hash.Code() + "}, " + method.Params[0].Name + ")\n\n"

			if method.MethodType != ast2.Stream {
				result += fmt.Sprintf(`
	respMsg := &%s{}
	err = peer.ReadMessage(respMsg)
	if err != nil{
		return nil, err
	}
	
	
	return respMsg, nil
`, method.Returns[0].Type.ObjectName)
			} else {
				result += "\tif err != nil{\n"
				result += "\t\t return nil, err\n"
				result += "\t}\n"
				result += "\treturn peer, nil\n"
			}

			result += "}\n\n"
		}
	}
}

func fillTagsByHandlerName() {
	result += "var tagsByHandlerName = map[string]map[string]string{\n"
	for _, service := range ast.Chateau.Services {
		for _, method := range service.Methods {
			var tags string
			for j := 0; j < len(method.Tags); j++ {
				tags += "\"" + method.Tags[j].Name + "\":\"" + method.Tags[j].Value + "\""
				if j != len(method.Tags)-1 {
					tags += ","
				}
			}
			result += "\t\"" + method.Name + "\":{" + tags + "},\n"
		}
	}
	result += "}\n\n"
}

func fillServices() {
	for _, service := range ast.Chateau.Services {
		result += "type " + service.Name + " interface { \n"
		for _, method := range service.Methods {
			result += "\t" + method.Name + "(ctx context.Context, "
			if method.MethodType == ast2.Stream {
				result += "peer *peer.Peer, "
			}
			for i, param := range method.Params {
				result += param.Name + " "
				if param.Type.IsArray {
					result += "["
					if param.Type.ArrSize != 0 {
						result += strconv.Itoa(param.Type.ArrSize)
					}
					result += "]"
				}

				if param.Type.Type == ast2.Object {
					result += "*" + param.Type.ObjectName
				} else {
					result += ast2.AstTypeToGoType[param.Type.Type]
				}
				if i != len(method.Params)-1 {
					result += ", "
				}
			}
			result += ") "
			if method.MethodType != ast2.Stream {
				result += "("
				for i, ret := range method.Returns {
					if ret.Type.IsArray {
						result += "["
						if ret.Type.ArrSize != 0 {
							result += strconv.Itoa(ret.Type.ArrSize)
						}
						result += "]"
					}

					if ret.Type.Type == ast2.Object {
						result += "*" + ret.Type.ObjectName
					} else {
						result += ast2.AstTypeToGoType[ret.Type.Type]
					}
					if i != len(method.Returns)-1 {
						result += ", "
					}
				}
				result += ", "
			}
			result += "error"
			if method.MethodType != ast2.Stream {
				result += ")"
			}
			result += "\n"
		}
		result += "}\n\n"
	}
}

func fillHandlerHashMap() {
	result += "var handlerHashMap = map[string]map[string]hash.HandlerHash{\n"
	for _, service := range ast.Chateau.Services {
		result += "\t\"" + service.Name + "\":{\n"
		for _, method := range service.Methods {
			result += "\t\t\"" + method.Name + "\":" + "hash.HandlerHash{" + method.Hash.Code() + "},\n"
		}
		result += "\t},\n"
	}
	result += "}\n\n"
}

func fillSqueezes() {
	for _, service := range ast.Chateau.Services {
		for _, method := range service.Methods {
			if method.MethodType == ast2.Handler {
				result += fmt.Sprintf(`func %sSqueeze(fnc func(context.Context, *%s) (*%s, error)) server.HandlerFunc {
	return func(ctx context.Context, msg message.Message) (message.Message, error) {
		if _, ok := msg.(*%s); ok {
			return fnc(ctx, msg.(*%s))
		} else {
			return nil, errors.New("unknown message type: expected %s")
		}
	}
}`+"\n\n", method.Name, method.Params[0].Type.ObjectName, method.Returns[0].Type.ObjectName, method.Params[0].Type.ObjectName, method.Params[0].Type.ObjectName, method.Params[0].Type.ObjectName)
			} else {
				result += fmt.Sprintf(`func %sSqueeze(fnc func(context.Context, *peer.Peer, *%s) error) server.StreamFunc {
	return func(ctx context.Context, peer *peer.Peer, msg message.Message) error {
		if _, ok := msg.(*%s); ok {
			return fnc(ctx, peer, msg.(*%s))
		} else {
			return errors.New("unknown message type: expected %s")
		}
	}
}`+"\n\n", method.Name, method.Params[0].Type.ObjectName, method.Params[0].Type.ObjectName, method.Params[0].Type.ObjectName, method.Params[0].Type.ObjectName)
			}
		}
	}
}

func fillObjects() error {
	ot, err := templates.NewObjectTemplate()
	if err != nil {
		return errors.Wrap(err, "failed to create object template")
	}

	var genObject string
	for _, object := range ast.Chateau.ObjectDefinitions {
		genObject, err = ot.Gen(object)
		if err != nil {
			return errors.Wrap(err, "failed to generate object")
		}

		result += genObject
	}

	return nil
}

func fillGetHandlers() {
	var endpointArgs string
	for i, service := range ast.Chateau.Services {
		endpointArgs += string(unicode.ToLower(rune(service.Name[0])))
		if len(service.Name) > 1 {
			endpointArgs += service.Name[1:]
		}
		endpointArgs += " " + service.Name

		if i != len(ast.Chateau.Services)-1 {
			endpointArgs += ","
		}
	}
	result += fmt.Sprintf("func GetHandlers(%s) map[hash.HandlerHash]*server.Handler {\n", endpointArgs)
	result += "\thandlers := make(map[hash.HandlerHash]*server.Handler)\n\n"
	for _, service := range ast.Chateau.Services {
		for _, method := range service.Methods {
			var methodType string
			if method.MethodType == ast2.Handler {
				methodType = "server.HandlerT"
			} else if method.MethodType == ast2.Stream {
				methodType = "server.StreamT"
			}
			var serviceNameLower string
			serviceNameLower += string(unicode.ToLower(rune(service.Name[0])))
			if len(service.Name) > 1 {
				serviceNameLower += service.Name[1:]
			}
			result += "\tvar callFunc" + method.Name + " server." + string(method.MethodType) + "Func\n"
			result += "\tif " + serviceNameLower + " != nil {\n"
			result += "\t\tcallFunc" + method.Name + "= " + method.Name + "Squeeze(" + serviceNameLower + "." + method.Name + ")\n"
			result += "\t}\n\n"
			result += fmt.Sprintf("\t"+`handlers[hash.HandlerHash{%s}] = &server.Handler{
		CallFunc%s:      callFunc%s,
		HandlerType:     %s,
		RequestMsgType:  &%s{},
		ResponseMsgType: &%s{},
		Tags:            tagsByHandlerName["%s"],
	}`+"\n\n", method.Hash.Code(), string(method.MethodType), method.Name, methodType, method.Params[0].Type.ObjectName, method.Returns[0].Type.ObjectName, method.Name)
		}
	}
	result += "\treturn handlers\n"
	result += "}\n\n"
}

func fillEmptyGetHandlers() {
	var endpointArgs string
	for i, service := range ast.Chateau.Services {
		endpointArgs += string(unicode.ToLower(rune(service.Name[0])))
		if len(service.Name) > 1 {
			endpointArgs += service.Name[1:]
		}
		endpointArgs += " " + service.Name

		if i != len(ast.Chateau.Services)-1 {
			endpointArgs += ","
		}
	}
	result += "func GetEmptyHandlers() map[hash.HandlerHash]*server.Handler {\n"
	result += "\thandlers := make(map[hash.HandlerHash]*server.Handler)\n\n"
	for _, service := range ast.Chateau.Services {
		for _, method := range service.Methods {
			var methodType string
			if method.MethodType == ast2.Handler {
				methodType = "server.HandlerT"
			} else if method.MethodType == ast2.Stream {
				methodType = "server.StreamT"
			}
			var serviceNameLower string
			serviceNameLower += string(unicode.ToLower(rune(service.Name[0])))
			if len(service.Name) > 1 {
				serviceNameLower += service.Name[1:]
			}
			result += fmt.Sprintf("\t"+`handlers[hash.HandlerHash{%s}] = &server.Handler{
		HandlerType:     %s,
		RequestMsgType:  &%s{},
		ResponseMsgType: &%s{},
	}`+"\n\n", method.Hash.Code(), methodType, method.Params[0].Type.ObjectName, method.Returns[0].Type.ObjectName)
		}
	}
	result += "\treturn handlers\n"
	result += "}\n\n"
}

func fillNewServer() {
	var endpointArgs string
	var endpointNames string
	for i, service := range ast.Chateau.Services {
		endpointArgs += string(unicode.ToLower(rune(service.Name[0])))
		endpointNames += string(unicode.ToLower(rune(service.Name[0])))
		if len(service.Name) > 1 {
			endpointArgs += service.Name[1:]
			endpointNames += service.Name[1:]
		}
		endpointArgs += " " + service.Name

		if i != len(ast.Chateau.Services)-1 {
			endpointArgs += ","
		}
	}

	result += fmt.Sprintf("func NewServer(cfg *server.Config, logger *zap.Logger, %s) *server.Server {\n", endpointArgs)
	result += fmt.Sprintf("\thandlers := GetHandlers(%s)\n\n", endpointNames)
	result += "\treturn server.NewServer(cfg, logger, handlers)\n"
	result += "}\n\n"
}

func fillCallClientMethod() {
	result += "func CallClientMethod(ctx context.Context, host string, port int, serviceName string, methodName string, req message.Message) (message.Message, error) {\n"
	for _, service := range ast.Chateau.Services {
		result += "\tif serviceName == \"" + service.Name + "\" {\n"
		for _, method := range service.Methods {
			result += "\t\tif methodName == \"" + method.Name + "\" {\n"
			if method.MethodType == ast2.Stream {
				result += "\t\t}\n\n"
				continue
			}
			result += "\t\t\tclient, err := NewClient" + service.Name + "(host, port)\n"
			result += "\t\t\tif err != nil {\n"
			result += "\t\t\t\treturn nil, err\n"
			result += "\t\t\t}\n"
			result += "\t\t\treturn client." + method.Name + "(ctx, req.(*" + method.Params[0].Type.ObjectName + "))\n"
			result += "\t\t}\n"
		}
		result += "\t}\n\n"
	}
	result += "\treturn nil, errors.New(\"unknown service or method\")\n"
	result += "}\n\n"
}
