package gen

import (
	"fmt"
	ast2 "github.com/oringik/crypto-chateau/gen/ast"
	"github.com/oringik/crypto-chateau/gen/conv"
)

func fillV1Unmarshal(obj *ast2.ObjectDefinition) {
	alreadyWasArraySymb := ":"

	for _, field := range obj.Fields {
		convFunction := conv.ConvFunctionUnmarshalByType(field.Type.Type)
		if field.Type.Type == ast2.Object {
			if field.Type.IsArray {
				result += fmt.Sprintf("\t"+`_, arr, err %s= conv.GetArray(params["%s"])`+"\n", alreadyWasArraySymb, field.Name)
				result += "\tif err != nil {\n\t\treturn err\n\t}\n"
				result += "\tfor _, objBytes := range arr {\n"
				result += "\t\tvar curObj *" + field.Type.ObjectName + "\n"
				result += fmt.Sprintf("\t\t"+`conv.%s(curObj,objBytes)`+"\n", convFunction)
				result += fmt.Sprintf("\t\to.%s = append(o.%s, curObj)\n", field.Name, field.Name)
				result += "\t}\n"

				alreadyWasArraySymb = ""
			} else {
				result += fmt.Sprintf("\to.%s = &%s{}\n", field.Name, field.Type.ObjectName)
				result += fmt.Sprintf("\t"+`conv.%s(o.%s,params["%s"])`+"\n", convFunction, field.Name, field.Name)
			}
		} else {
			if field.Type.IsArray {
				result += fmt.Sprintf("\t"+`_, arr, err %s= conv.GetArray(params["%s"])`+"\n", alreadyWasArraySymb, field.Name)
				result += "\tif err != nil {\n\t\treturn err\n\t}\n"
				var iOrMiss string
				if field.Type.ArrSize != 0 {
					iOrMiss = "i"
				} else {
					iOrMiss = "-"
				}
				result += fmt.Sprintf("\tfor %s, valByte := range arr {\n", iOrMiss)
				if field.Type.ArrSize != 0 {
					result += fmt.Sprintf("\t\to.%s[i] = conv.%s(valByte)\n", field.Name, convFunction)
				} else {
					result += "\t\tvar curVal " + ast2.AstTypeToGoType[field.Type.Type] + "\n"
					result += fmt.Sprintf("\t\t"+`curVal = conv.%s(valByte)`+"\n", convFunction)
					result += fmt.Sprintf("\t\to.%s = append(o.%s, curVal)\n", field.Name, field.Name)
				}
				result += "\t}\n"

				alreadyWasArraySymb = ""
			} else {
				result += fmt.Sprintf("\t"+`o.%s = conv.%s(params["%s"])`+"\n", field.Name, convFunction, field.Name)
			}
		}
	}
	result += "\n\treturn nil\n}\n\n"
}

func fillV1Marshal(obj *ast2.ObjectDefinition) {
	result += "\tvar buf []byte\n"
	result += "\t" + `buf = append(buf, '{')` + "\n"
	for i, field := range obj.Fields {
		convFunction := conv.ConvFunctionMarhsalByType(field.Type.Type)
		result += fmt.Sprintf("\tvar result%s []byte\n", field.Name)
		result += fmt.Sprintf("\t"+`result%s = append(result%s, []byte("%s:")...)`, field.Name, field.Name, field.Name) + "\n"
		if field.Type.IsArray {
			result += fmt.Sprintf("\t"+`result%s = append(result%s, '[')`, field.Name, field.Name) + "\n"
			result += "\tfor i, val := range o." + field.Name + " {\n"
			result += fmt.Sprintf("\t\tresult%s = append(result%s, conv.%s(val)...)\n", field.Name, field.Name, convFunction)
			result += "\t\tif i != len(o." + field.Name + ") - 1 {\n"
			result += "\t\t\t" + fmt.Sprintf(`result%s = append(result%s, ',')`, field.Name, field.Name) + "\n"
			result += "\t\t}\n"
			result += "\t}\n"
			result += fmt.Sprintf("\t"+`result%s = append(result%s, ']')`, field.Name, field.Name) + "\n\n"
		} else {
			result += fmt.Sprintf("\tresult%s = append(result%s, conv.%s(o.%s)...)\n", field.Name, field.Name, convFunction, field.Name)
		}
		result += fmt.Sprintf("\tbuf = append(buf, result%s...)\n", field.Name)
		if i != len(obj.Fields)-1 {
			result += "\tbuf = append(buf, ',')\n"
		}
	}
	result += "\t" + `buf = append(buf, '}')` + "\n"
	// return generated bytes
	result += "\n\treturn buf\n }\n\n"
}
