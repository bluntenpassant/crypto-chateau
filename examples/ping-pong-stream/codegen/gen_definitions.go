// Code generated by crypto-chateau 1.0.0 DO NOT EDIT.

package endpoints

import (
	"context"
	"net"
	"strconv"

	"github.com/pkg/errors"
	"go.uber.org/zap"

	"github.com/oringik/crypto-chateau/gen/conv"
	"github.com/oringik/crypto-chateau/gen/hash"
	"github.com/oringik/crypto-chateau/message"
	"github.com/oringik/crypto-chateau/peer"
	"github.com/oringik/crypto-chateau/server"
	"github.com/oringik/crypto-chateau/transport"
)

var tagsByHandlerName = map[string]map[string]string{
	"PingPong": {"key": "val", "ajsdajsd": "asdasd"},
}

type Reverse interface {
	PingPong(ctx context.Context, peer *peer.Peer, req *PingPongRequest) error
}

var handlerHashMap = map[string]map[string]hash.HandlerHash{
	"Reverse": {
		"PingPong": hash.HandlerHash{0x52, 0x65, 0x76, 065},
	},
}

func PingPongSqueeze(fnc func(context.Context, *peer.Peer, *PingPongRequest) error) server.StreamFunc {
	return func(ctx context.Context, peer *peer.Peer, msg message.Message) error {
		if _, ok := msg.(*PingPongRequest); ok {
			return fnc(ctx, peer, msg.(*PingPongRequest))
		} else {
			return errors.New("unknown message type: expected PingPongRequest")
		}
	}
}

type PingPongRequest struct {
}

var _ message.Message = (*PingPongRequest)(nil)

func (o *PingPongRequest) Marshal() []byte {
	var (
		b = make([]byte, 0, 0)
	)

	size := conv.ConvertSizeToBytes(0)
	b = append(b, size...)

	size = conv.ConvertSizeToBytes(len(b) - len(size))
	for i := 0; i < len(size); i++ {
		b[i] = size[i]
	}

	return b
}

func (o *PingPongRequest) Unmarshal(b *conv.BinaryIterator) error {
	binaryCtx := struct {
		err                error
		size, arrSize, pos int
		buf, arrBuf        *conv.BinaryIterator
	}{}

	binaryCtx.err = nil

	return nil
}

type Ping struct {
	Req string
	Re  []string
}

var _ message.Message = (*Ping)(nil)

func (o *Ping) Marshal() []byte {
	var (
		b = make([]byte, 0, 32)
	)

	size := conv.ConvertSizeToBytes(0)
	b = append(b, size...)
	b = append(b, conv.ConvertSizeToBytes(len([]byte(o.Req)))...)
	b = append(b, conv.ConvertStringToBytes(o.Req)...)
	arrBufRe := make([]byte, 0, 128)
	for _, elRe := range o.Re {
		arrBufRe = append(arrBufRe, conv.ConvertSizeToBytes(len([]byte(elRe)))...)
		arrBufRe = append(arrBufRe, conv.ConvertStringToBytes(elRe)...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBufRe))...)
	b = append(b, arrBufRe...)

	size = conv.ConvertSizeToBytes(len(b) - len(size))
	for i := 0; i < len(size); i++ {
		b[i] = size[i]
	}

	return b
}

func (o *Ping) Unmarshal(b *conv.BinaryIterator) error {
	binaryCtx := struct {
		err                error
		size, arrSize, pos int
		buf, arrBuf        *conv.BinaryIterator
	}{}

	binaryCtx.err = nil

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Req size")
	}
	binaryCtx.buf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Req")
	}
	o.Req = conv.ConvertBytesToString(binaryCtx.buf)

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Re size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Re")
	}
	for binaryCtx.arrBuf.HasNext() {
		var elRe string

		binaryCtx.size, binaryCtx.err = binaryCtx.arrBuf.NextSize()
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read Re size")
		}
		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(binaryCtx.size)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read Re")
		}
		elRe = conv.ConvertBytesToString(binaryCtx.buf)

		o.Re = append(o.Re, elRe)

	}

	return nil
}

type Pong struct {
	Resp string
}

var _ message.Message = (*Pong)(nil)

func (o *Pong) Marshal() []byte {
	var (
		b = make([]byte, 0, 16)
	)

	size := conv.ConvertSizeToBytes(0)
	b = append(b, size...)
	b = append(b, conv.ConvertSizeToBytes(len([]byte(o.Resp)))...)
	b = append(b, conv.ConvertStringToBytes(o.Resp)...)

	size = conv.ConvertSizeToBytes(len(b) - len(size))
	for i := 0; i < len(size); i++ {
		b[i] = size[i]
	}

	return b
}

func (o *Pong) Unmarshal(b *conv.BinaryIterator) error {
	binaryCtx := struct {
		err                error
		size, arrSize, pos int
		buf, arrBuf        *conv.BinaryIterator
	}{}

	binaryCtx.err = nil

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Resp size")
	}
	binaryCtx.buf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Resp")
	}
	o.Resp = conv.ConvertBytesToString(binaryCtx.buf)

	return nil
}
func GetHandlers(reverse Reverse) map[hash.HandlerHash]*server.Handler {
	handlers := make(map[hash.HandlerHash]*server.Handler)

	var callFuncPingPong server.StreamFunc
	if reverse != nil {
		callFuncPingPong = PingPongSqueeze(reverse.PingPong)
	}

	handlers[hash.HandlerHash{0x52, 0x65, 0x76, 065}] = &server.Handler{
		CallFuncStream:  callFuncPingPong,
		HandlerType:     server.StreamT,
		RequestMsgType:  &PingPongRequest{},
		ResponseMsgType: &Pong{},
		Tags:            tagsByHandlerName["PingPong"],
	}

	return handlers
}

func GetEmptyHandlers() map[hash.HandlerHash]*server.Handler {
	handlers := make(map[hash.HandlerHash]*server.Handler)

	handlers[hash.HandlerHash{0x52, 0x65, 0x76, 065}] = &server.Handler{
		HandlerType:     server.StreamT,
		RequestMsgType:  &PingPongRequest{},
		ResponseMsgType: &Pong{},
	}

	return handlers
}

func NewServer(cfg *server.Config, logger *zap.Logger, reverse Reverse) *server.Server {
	handlers := GetHandlers(reverse)

	return server.NewServer(cfg, logger, handlers)
}

func CallClientMethod(ctx context.Context, host string, port int, serviceName string, methodName string, req message.Message) (message.Message, error) {
	if serviceName == "Reverse" {
		if methodName == "PingPong" {
		}

	}

	return nil, errors.New("unknown service or method")
}

type ClientReverse struct {
	peer *peer.Peer
}

func NewClientReverse(host string, port int) (*ClientReverse, error) {
	conn, err := net.Dial("tcp", host+":"+strconv.Itoa(port))
	if err != nil {
		return nil, err
	}
	conn, err = transport.ServerHandshake(conn)
	if err != nil {
		return nil, err
	}
	securedPeer := peer.NewPeer(conn)
	client := &ClientReverse{peer: securedPeer}
	return client, nil
}

func (c *ClientReverse) PingPong(ctx context.Context, req *PingPongRequest) (*peer.Peer, error) {
	err := c.peer.SendRequestClient(hash.HandlerHash{0x52, 0x65, 0x76, 065}, req)

	if err != nil {
		return nil, err
	}
	return c.peer, nil
}
