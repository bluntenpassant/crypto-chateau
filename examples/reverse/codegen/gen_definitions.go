// Code generated by crypto-chateau 1.0.0 DO NOT EDIT.

package endpoints

import (
	"context"
	"net"
	"strconv"

	"github.com/pkg/errors"
	"go.uber.org/zap"

	"github.com/oringik/crypto-chateau/gen/conv"
	"github.com/oringik/crypto-chateau/gen/hash"
	"github.com/oringik/crypto-chateau/message"
	"github.com/oringik/crypto-chateau/peer"
	"github.com/oringik/crypto-chateau/server"
	"github.com/oringik/crypto-chateau/transport/handshake"
	"github.com/oringik/crypto-chateau/transport/multiplex_conn"
)

var tagsByHandlerName = map[string]map[string]string{
	"ReverseMagicString": {"key": "val", "ajsdajsd": "asdasd"},
	"Rasd":               {"key": "val", "ajsdajsd": "asdasd"},
}

type Reverse interface {
	ReverseMagicString(ctx context.Context, req *ReverseMagicStringRequest) (*ReverseMagicStringResponse, error)
	Rasd(ctx context.Context, req *ReverseMagicStringRequest) (*ReverseMagicStringResponse, error)
}

var handlerHashMap = map[string]map[string]hash.HandlerHash{
	"Reverse": {
		"ReverseMagicString": hash.HandlerHash{0x90, 0xA, 0xDC, 0x45},
		"Rasd":               hash.HandlerHash{0xCB, 0xB1, 0x2D, 0x3D},
	},
}

func ReverseMagicStringSqueeze(fnc func(context.Context, *ReverseMagicStringRequest) (*ReverseMagicStringResponse, error)) server.HandlerFunc {
	return func(ctx context.Context, msg message.Message) (message.Message, error) {
		if _, ok := msg.(*ReverseMagicStringRequest); ok {
			return fnc(ctx, msg.(*ReverseMagicStringRequest))
		} else {
			return nil, errors.New("unknown message type: expected ReverseMagicStringRequest")
		}
	}
}

func RasdSqueeze(fnc func(context.Context, *ReverseMagicStringRequest) (*ReverseMagicStringResponse, error)) server.HandlerFunc {
	return func(ctx context.Context, msg message.Message) (message.Message, error) {
		if _, ok := msg.(*ReverseMagicStringRequest); ok {
			return fnc(ctx, msg.(*ReverseMagicStringRequest))
		} else {
			return nil, errors.New("unknown message type: expected ReverseMagicStringRequest")
		}
	}
}

type ReverseCommonObject struct {
	Key   [16]byte
	Value [32]string
}

var _ message.Message = (*ReverseCommonObject)(nil)

func (o *ReverseCommonObject) Marshal() []byte {
	var (
		b = make([]byte, 0, 32)
	)

	size := conv.ConvertSizeToBytes(0)
	b = append(b, size...)
	arrBufKey := make([]byte, 0, 128)
	for _, elKey := range o.Key {
		arrBufKey = append(arrBufKey, conv.ConvertByteToBytes(elKey)...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBufKey))...)
	b = append(b, arrBufKey...)
	arrBufValue := make([]byte, 0, 128)
	for _, elValue := range o.Value {
		arrBufValue = append(arrBufValue, conv.ConvertSizeToBytes(len([]byte(elValue)))...)
		arrBufValue = append(arrBufValue, conv.ConvertStringToBytes(elValue)...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBufValue))...)
	b = append(b, arrBufValue...)

	size = conv.ConvertSizeToBytes(len(b) - len(size))
	for i := 0; i < len(size); i++ {
		b[i] = size[i]
	}

	return b
}

func (o *ReverseCommonObject) Unmarshal(b *conv.BinaryIterator) error {
	binaryCtx := struct {
		err                error
		size, arrSize, pos int
		buf, arrBuf        *conv.BinaryIterator
	}{}

	binaryCtx.err = nil
	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Key size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Key")
	}
	binaryCtx.pos = 0
	for binaryCtx.arrBuf.HasNext() {
		var elKey byte

		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(1)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read Key")
		}
		elKey = conv.ConvertBytesToByte(binaryCtx.buf)

		o.Key[binaryCtx.pos] = elKey
		binaryCtx.pos++
	}
	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Value size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Value")
	}
	binaryCtx.pos = 0
	for binaryCtx.arrBuf.HasNext() {
		var elValue string

		binaryCtx.size, binaryCtx.err = binaryCtx.arrBuf.NextSize()
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read Value size")
		}
		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(binaryCtx.size)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read Value")
		}
		elValue = conv.ConvertBytesToString(binaryCtx.buf)

		o.Value[binaryCtx.pos] = elValue
		binaryCtx.pos++
	}

	return nil
}

func (o *ReverseCommonObject) Copy() message.Message {
	return &ReverseCommonObject{}
}

type ReverseMagicStringRequest struct {
	MagicString      string
	MagicInt8        int8
	MagicInt16       int16
	MagicInt32       int32
	MagicInt64       int64
	MagicUInt8       uint8
	MagicUInt16      uint16
	MagicUInt32      uint32
	MagicUInt64      uint64
	MagicBool        bool
	MagicBytes       []byte
	MagicObject      ReverseCommonObject
	MagicObjectArray []ReverseCommonObject
}

var _ message.Message = (*ReverseMagicStringRequest)(nil)

func (o *ReverseMagicStringRequest) Marshal() []byte {
	var (
		b = make([]byte, 0, 208)
	)

	size := conv.ConvertSizeToBytes(0)
	b = append(b, size...)
	b = append(b, conv.ConvertSizeToBytes(len([]byte(o.MagicString)))...)
	b = append(b, conv.ConvertStringToBytes(o.MagicString)...)
	b = append(b, conv.ConvertInt8ToBytes(o.MagicInt8)...)
	b = append(b, conv.ConvertInt16ToBytes(o.MagicInt16)...)
	b = append(b, conv.ConvertInt32ToBytes(o.MagicInt32)...)
	b = append(b, conv.ConvertInt64ToBytes(o.MagicInt64)...)
	b = append(b, conv.ConvertUint8ToBytes(o.MagicUInt8)...)
	b = append(b, conv.ConvertUint16ToBytes(o.MagicUInt16)...)
	b = append(b, conv.ConvertUint32ToBytes(o.MagicUInt32)...)
	b = append(b, conv.ConvertUint64ToBytes(o.MagicUInt64)...)
	b = append(b, conv.ConvertBoolToBytes(o.MagicBool)...)
	arrBufMagicBytes := make([]byte, 0, 128)
	for _, elMagicBytes := range o.MagicBytes {
		arrBufMagicBytes = append(arrBufMagicBytes, conv.ConvertByteToBytes(elMagicBytes)...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBufMagicBytes))...)
	b = append(b, arrBufMagicBytes...)
	b = append(b, o.MagicObject.Marshal()...)
	arrBufMagicObjectArray := make([]byte, 0, 128)
	for _, elMagicObjectArray := range o.MagicObjectArray {
		arrBufMagicObjectArray = append(arrBufMagicObjectArray, elMagicObjectArray.Marshal()...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBufMagicObjectArray))...)
	b = append(b, arrBufMagicObjectArray...)

	size = conv.ConvertSizeToBytes(len(b) - len(size))
	for i := 0; i < len(size); i++ {
		b[i] = size[i]
	}

	return b
}

func (o *ReverseMagicStringRequest) Unmarshal(b *conv.BinaryIterator) error {
	binaryCtx := struct {
		err                error
		size, arrSize, pos int
		buf, arrBuf        *conv.BinaryIterator
	}{}

	binaryCtx.err = nil

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicString size")
	}
	binaryCtx.buf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicString")
	}
	o.MagicString = conv.ConvertBytesToString(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt8")
	}
	o.MagicInt8 = conv.ConvertBytesToInt8(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(2)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt16")
	}
	o.MagicInt16 = conv.ConvertBytesToInt16(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(4)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt32")
	}
	o.MagicInt32 = conv.ConvertBytesToInt32(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(8)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt64")
	}
	o.MagicInt64 = conv.ConvertBytesToInt64(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt8")
	}
	o.MagicUInt8 = conv.ConvertBytesToUint8(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(2)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt16")
	}
	o.MagicUInt16 = conv.ConvertBytesToUint16(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(4)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt32")
	}
	o.MagicUInt32 = conv.ConvertBytesToUint32(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(8)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt64")
	}
	o.MagicUInt64 = conv.ConvertBytesToUint64(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBool")
	}
	o.MagicBool = conv.ConvertBytesToBool(binaryCtx.buf)

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBytes size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBytes")
	}
	for binaryCtx.arrBuf.HasNext() {
		var elMagicBytes byte

		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(1)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read MagicBytes")
		}
		elMagicBytes = conv.ConvertBytesToByte(binaryCtx.buf)

		o.MagicBytes = append(o.MagicBytes, elMagicBytes)

	}

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObject size")
	}
	binaryCtx.buf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObject")
	}
	if binaryCtx.err = o.MagicObject.Unmarshal(binaryCtx.buf); binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to unmarshal MagicObject")
	}

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray")
	}
	for binaryCtx.arrBuf.HasNext() {
		var elMagicObjectArray ReverseCommonObject

		binaryCtx.size, binaryCtx.err = binaryCtx.arrBuf.NextSize()
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray size")
		}
		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(binaryCtx.size)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray")
		}
		if binaryCtx.err = elMagicObjectArray.Unmarshal(binaryCtx.buf); binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to unmarshal MagicObjectArray")
		}

		o.MagicObjectArray = append(o.MagicObjectArray, elMagicObjectArray)

	}

	return nil
}

func (o *ReverseMagicStringRequest) Copy() message.Message {
	return &ReverseMagicStringRequest{}
}

type ReverseMagicStringResponse struct {
	ReversedMagicString string
	MagicInt8           int8
	MagicInt16          int16
	MagicInt32          int32
	MagicInt64          int64
	MagicUInt8          uint8
	MagicUInt16         uint16
	MagicUInt32         uint32
	MagicUInt64         uint64
	MagicBool           bool
	MagicBytes          []byte
	MagicObject         ReverseCommonObject
	MagicObjectArray    []ReverseCommonObject
}

var _ message.Message = (*ReverseMagicStringResponse)(nil)

func (o *ReverseMagicStringResponse) Marshal() []byte {
	var (
		b = make([]byte, 0, 208)
	)

	size := conv.ConvertSizeToBytes(0)
	b = append(b, size...)
	b = append(b, conv.ConvertSizeToBytes(len([]byte(o.ReversedMagicString)))...)
	b = append(b, conv.ConvertStringToBytes(o.ReversedMagicString)...)
	b = append(b, conv.ConvertInt8ToBytes(o.MagicInt8)...)
	b = append(b, conv.ConvertInt16ToBytes(o.MagicInt16)...)
	b = append(b, conv.ConvertInt32ToBytes(o.MagicInt32)...)
	b = append(b, conv.ConvertInt64ToBytes(o.MagicInt64)...)
	b = append(b, conv.ConvertUint8ToBytes(o.MagicUInt8)...)
	b = append(b, conv.ConvertUint16ToBytes(o.MagicUInt16)...)
	b = append(b, conv.ConvertUint32ToBytes(o.MagicUInt32)...)
	b = append(b, conv.ConvertUint64ToBytes(o.MagicUInt64)...)
	b = append(b, conv.ConvertBoolToBytes(o.MagicBool)...)
	arrBufMagicBytes := make([]byte, 0, 128)
	for _, elMagicBytes := range o.MagicBytes {
		arrBufMagicBytes = append(arrBufMagicBytes, conv.ConvertByteToBytes(elMagicBytes)...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBufMagicBytes))...)
	b = append(b, arrBufMagicBytes...)
	b = append(b, o.MagicObject.Marshal()...)
	arrBufMagicObjectArray := make([]byte, 0, 128)
	for _, elMagicObjectArray := range o.MagicObjectArray {
		arrBufMagicObjectArray = append(arrBufMagicObjectArray, elMagicObjectArray.Marshal()...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBufMagicObjectArray))...)
	b = append(b, arrBufMagicObjectArray...)

	size = conv.ConvertSizeToBytes(len(b) - len(size))
	for i := 0; i < len(size); i++ {
		b[i] = size[i]
	}

	return b
}

func (o *ReverseMagicStringResponse) Unmarshal(b *conv.BinaryIterator) error {
	binaryCtx := struct {
		err                error
		size, arrSize, pos int
		buf, arrBuf        *conv.BinaryIterator
	}{}

	binaryCtx.err = nil

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read ReversedMagicString size")
	}
	binaryCtx.buf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read ReversedMagicString")
	}
	o.ReversedMagicString = conv.ConvertBytesToString(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt8")
	}
	o.MagicInt8 = conv.ConvertBytesToInt8(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(2)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt16")
	}
	o.MagicInt16 = conv.ConvertBytesToInt16(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(4)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt32")
	}
	o.MagicInt32 = conv.ConvertBytesToInt32(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(8)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt64")
	}
	o.MagicInt64 = conv.ConvertBytesToInt64(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt8")
	}
	o.MagicUInt8 = conv.ConvertBytesToUint8(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(2)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt16")
	}
	o.MagicUInt16 = conv.ConvertBytesToUint16(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(4)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt32")
	}
	o.MagicUInt32 = conv.ConvertBytesToUint32(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(8)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt64")
	}
	o.MagicUInt64 = conv.ConvertBytesToUint64(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBool")
	}
	o.MagicBool = conv.ConvertBytesToBool(binaryCtx.buf)

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBytes size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBytes")
	}
	for binaryCtx.arrBuf.HasNext() {
		var elMagicBytes byte

		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(1)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read MagicBytes")
		}
		elMagicBytes = conv.ConvertBytesToByte(binaryCtx.buf)

		o.MagicBytes = append(o.MagicBytes, elMagicBytes)

	}

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObject size")
	}
	binaryCtx.buf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObject")
	}
	if binaryCtx.err = o.MagicObject.Unmarshal(binaryCtx.buf); binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to unmarshal MagicObject")
	}

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray")
	}
	for binaryCtx.arrBuf.HasNext() {
		var elMagicObjectArray ReverseCommonObject

		binaryCtx.size, binaryCtx.err = binaryCtx.arrBuf.NextSize()
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray size")
		}
		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(binaryCtx.size)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray")
		}
		if binaryCtx.err = elMagicObjectArray.Unmarshal(binaryCtx.buf); binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to unmarshal MagicObjectArray")
		}

		o.MagicObjectArray = append(o.MagicObjectArray, elMagicObjectArray)

	}

	return nil
}

func (o *ReverseMagicStringResponse) Copy() message.Message {
	return &ReverseMagicStringResponse{}
}
func GetHandlers(reverse Reverse) map[hash.HandlerHash]*server.Handler {
	handlers := make(map[hash.HandlerHash]*server.Handler)

	var callFuncReverseMagicString server.HandlerFunc
	if reverse != nil {
		callFuncReverseMagicString = ReverseMagicStringSqueeze(reverse.ReverseMagicString)
	}

	handlers[hash.HandlerHash{0x90, 0xA, 0xDC, 0x45}] = &server.Handler{
		CallFuncHandler: callFuncReverseMagicString,
		HandlerType:     server.HandlerT,
		RequestMsgType:  &ReverseMagicStringRequest{},
		ResponseMsgType: &ReverseMagicStringResponse{},
		Tags:            tagsByHandlerName["ReverseMagicString"],
	}

	var callFuncRasd server.HandlerFunc
	if reverse != nil {
		callFuncRasd = RasdSqueeze(reverse.Rasd)
	}

	handlers[hash.HandlerHash{0xCB, 0xB1, 0x2D, 0x3D}] = &server.Handler{
		CallFuncHandler: callFuncRasd,
		HandlerType:     server.HandlerT,
		RequestMsgType:  &ReverseMagicStringRequest{},
		ResponseMsgType: &ReverseMagicStringResponse{},
		Tags:            tagsByHandlerName["Rasd"],
	}

	return handlers
}

func GetEmptyHandlers() map[hash.HandlerHash]*server.Handler {
	handlers := make(map[hash.HandlerHash]*server.Handler)

	handlers[hash.HandlerHash{0x90, 0xA, 0xDC, 0x45}] = &server.Handler{
		HandlerType:     server.HandlerT,
		RequestMsgType:  &ReverseMagicStringRequest{},
		ResponseMsgType: &ReverseMagicStringResponse{},
	}

	handlers[hash.HandlerHash{0xCB, 0xB1, 0x2D, 0x3D}] = &server.Handler{
		HandlerType:     server.HandlerT,
		RequestMsgType:  &ReverseMagicStringRequest{},
		ResponseMsgType: &ReverseMagicStringResponse{},
	}

	return handlers
}

func NewServer(cfg *server.Config, logger *zap.Logger, reverse Reverse) *server.Server {
	handlers := GetHandlers(reverse)

	return server.NewServer(cfg, logger, handlers)
}

func CallClientMethod(ctx context.Context, host string, port int, serviceName string, methodName string, req message.Message) (message.Message, error) {
	if serviceName == "Reverse" {
		if methodName == "ReverseMagicString" {
			client, err := NewClientReverse(host, port)
			if err != nil {
				return nil, err
			}
			return client.ReverseMagicString(ctx, req.(*ReverseMagicStringRequest))
		}
		if methodName == "Rasd" {
			client, err := NewClientReverse(host, port)
			if err != nil {
				return nil, err
			}
			return client.Rasd(ctx, req.(*ReverseMagicStringRequest))
		}
	}

	return nil, errors.New("unknown service or method")
}

type ClientReverse struct {
	multiplexConnPool *multiplex_conn.MultiplexConnPool
}

func NewClientReverse(host string, port int) (*ClientReverse, error) {
	conn, err := net.Dial("tcp", host+":"+strconv.Itoa(port))
	if err != nil {
		return nil, err
	}
	conn, err = handshake.ServerHandshake(conn)
	if err != nil {
		return nil, err
	}
	multiplexConnPool := multiplex_conn.NewMultiplexConnPool(conn, true)
	multiplexConnPool.Run()
	client := &ClientReverse{multiplexConnPool: multiplexConnPool}
	return client, nil
}

func (c *ClientReverse) ReverseMagicString(ctx context.Context, req *ReverseMagicStringRequest) (*ReverseMagicStringResponse, error) {
	multiplexConn := c.multiplexConnPool.NewMultiplexConn()
	peer := peer.NewPeer(multiplexConn)
	err := peer.SendRequestClient(hash.HandlerHash{0x90, 0xA, 0xDC, 0x45}, req)

	respMsg := &ReverseMagicStringResponse{}
	err = peer.ReadMessage(respMsg)
	if err != nil {
		return nil, err
	}

	return respMsg, nil
}

func (c *ClientReverse) Rasd(ctx context.Context, req *ReverseMagicStringRequest) (*ReverseMagicStringResponse, error) {
	multiplexConn := c.multiplexConnPool.NewMultiplexConn()
	peer := peer.NewPeer(multiplexConn)
	err := peer.SendRequestClient(hash.HandlerHash{0xCB, 0xB1, 0x2D, 0x3D}, req)

	respMsg := &ReverseMagicStringResponse{}
	err = peer.ReadMessage(respMsg)
	if err != nil {
		return nil, err
	}

	return respMsg, nil
}
