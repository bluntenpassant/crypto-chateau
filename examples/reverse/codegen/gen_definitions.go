// Code generated by crypto-chateau 1.0.0 DO NOT EDIT.

package endpoints

import (
	"context"
	"net"
	"strconv"

	"github.com/pkg/errors"
	"go.uber.org/zap"

	"github.com/oringik/crypto-chateau/gen/conv"
	"github.com/oringik/crypto-chateau/gen/hash"
	"github.com/oringik/crypto-chateau/message"
	"github.com/oringik/crypto-chateau/peer"
	"github.com/oringik/crypto-chateau/server"
	"github.com/oringik/crypto-chateau/transport"
)

var tagsByHandlerName = map[string]map[string]string{
	"ReverseMagicString": {"key": "val", "ajsdajsd": "asdasd"},
}

type Reverse interface {
	ReverseMagicString(ctx context.Context, req *ReverseMagicStringRequest) (*ReverseMagicStringResponse, error)
}

var handlerHashMap = map[string]map[string]hash.HandlerHash{
	"Reverse": {
		"ReverseMagicString": hash.HandlerHash{0x52, 0x65, 0x76, 065},
	},
}

func ReverseMagicStringSqueeze(fnc func(context.Context, *ReverseMagicStringRequest) (*ReverseMagicStringResponse, error)) server.HandlerFunc {
	return func(ctx context.Context, msg message.Message) (message.Message, error) {
		if _, ok := msg.(*ReverseMagicStringRequest); ok {
			return fnc(ctx, msg.(*ReverseMagicStringRequest))
		} else {
			return nil, errors.New("unknown message type: expected ReverseMagicStringRequest")
		}
	}
}

type ReverseCommonObject struct {
	Key   [16]byte
	Value [32]string
}

var _ message.Message = (*ReverseCommonObject)(nil)

func (o *ReverseCommonObject) Marshal() []byte {
	var (
		arrBuf []byte
		b      = make([]byte, 0, 32)
	)

	size := conv.ConvertSizeToBytes(0)
	b = append(b, size...)
	arrBuf = make([]byte, 0, 128)
	for _, elKey := range o.Key {
		arrBuf = append(arrBuf, conv.ConvertByteToBytes(elKey)...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBuf))...)
	b = append(b, arrBuf...)
	arrBuf = make([]byte, 0, 128)
	for _, elValue := range o.Value {
		arrBuf = append(arrBuf, conv.ConvertSizeToBytes(len([]byte(elValue)))...)
		arrBuf = append(arrBuf, conv.ConvertStringToBytes(elValue)...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBuf))...)
	b = append(b, arrBuf...)

	size = conv.ConvertSizeToBytes(len(b) - len(size))
	for i := 0; i < len(size); i++ {
		b[i] = size[i]
	}

	return b
}

func (o *ReverseCommonObject) Unmarshal(b *conv.BinaryIterator) error {
	binaryCtx := struct {
		err                error
		size, arrSize, pos int
		buf, arrBuf        *conv.BinaryIterator
	}{}

	binaryCtx.err = nil
	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Key size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Key")
	}
	binaryCtx.pos = 0
	for binaryCtx.arrBuf.HasNext() {
		var elKey byte

		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(1)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read Key")
		}
		elKey = conv.ConvertBytesToByte(binaryCtx.buf)

		o.Key[binaryCtx.pos] = elKey
		binaryCtx.pos++
	}
	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Value size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read Value")
	}
	binaryCtx.pos = 0
	for binaryCtx.arrBuf.HasNext() {
		var elValue string

		binaryCtx.size, binaryCtx.err = binaryCtx.arrBuf.NextSize()
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read Value size")
		}
		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(binaryCtx.size)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read Value")
		}
		elValue = conv.ConvertBytesToString(binaryCtx.buf)

		o.Value[binaryCtx.pos] = elValue
		binaryCtx.pos++
	}

	return nil
}

type ReverseMagicStringRequest struct {
	MagicString      string
	MagicInt8        int8
	MagicInt16       int16
	MagicInt32       int32
	MagicInt64       int64
	MagicUInt8       uint8
	MagicUInt16      uint16
	MagicUInt32      uint32
	MagicUInt64      uint64
	MagicBool        bool
	MagicBytes       []byte
	MagicObject      ReverseCommonObject
	MagicObjectArray []ReverseCommonObject
}

var _ message.Message = (*ReverseMagicStringRequest)(nil)

func (o *ReverseMagicStringRequest) Marshal() []byte {
	var (
		arrBuf []byte
		b      = make([]byte, 0, 208)
	)

	size := conv.ConvertSizeToBytes(0)
	b = append(b, size...)
	b = append(b, conv.ConvertSizeToBytes(len([]byte(o.MagicString)))...)
	b = append(b, conv.ConvertStringToBytes(o.MagicString)...)
	b = append(b, conv.ConvertInt8ToBytes(o.MagicInt8)...)
	b = append(b, conv.ConvertInt16ToBytes(o.MagicInt16)...)
	b = append(b, conv.ConvertInt32ToBytes(o.MagicInt32)...)
	b = append(b, conv.ConvertInt64ToBytes(o.MagicInt64)...)
	b = append(b, conv.ConvertUint8ToBytes(o.MagicUInt8)...)
	b = append(b, conv.ConvertUint16ToBytes(o.MagicUInt16)...)
	b = append(b, conv.ConvertUint32ToBytes(o.MagicUInt32)...)
	b = append(b, conv.ConvertUint64ToBytes(o.MagicUInt64)...)
	b = append(b, conv.ConvertBoolToBytes(o.MagicBool)...)
	arrBuf = make([]byte, 0, 128)
	for _, elMagicBytes := range o.MagicBytes {
		arrBuf = append(arrBuf, conv.ConvertByteToBytes(elMagicBytes)...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBuf))...)
	b = append(b, arrBuf...)
	b = append(b, o.MagicObject.Marshal()...)
	arrBuf = make([]byte, 0, 128)
	for _, elMagicObjectArray := range o.MagicObjectArray {
		arrBuf = append(arrBuf, elMagicObjectArray.Marshal()...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBuf))...)
	b = append(b, arrBuf...)

	size = conv.ConvertSizeToBytes(len(b) - len(size))
	for i := 0; i < len(size); i++ {
		b[i] = size[i]
	}

	return b
}

func (o *ReverseMagicStringRequest) Unmarshal(b *conv.BinaryIterator) error {
	binaryCtx := struct {
		err                error
		size, arrSize, pos int
		buf, arrBuf        *conv.BinaryIterator
	}{}

	binaryCtx.err = nil

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicString size")
	}
	binaryCtx.buf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicString")
	}
	o.MagicString = conv.ConvertBytesToString(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt8")
	}
	o.MagicInt8 = conv.ConvertBytesToInt8(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(2)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt16")
	}
	o.MagicInt16 = conv.ConvertBytesToInt16(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(4)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt32")
	}
	o.MagicInt32 = conv.ConvertBytesToInt32(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(8)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt64")
	}
	o.MagicInt64 = conv.ConvertBytesToInt64(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt8")
	}
	o.MagicUInt8 = conv.ConvertBytesToUint8(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(2)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt16")
	}
	o.MagicUInt16 = conv.ConvertBytesToUint16(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(4)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt32")
	}
	o.MagicUInt32 = conv.ConvertBytesToUint32(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(8)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt64")
	}
	o.MagicUInt64 = conv.ConvertBytesToUint64(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBool")
	}
	o.MagicBool = conv.ConvertBytesToBool(binaryCtx.buf)

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBytes size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBytes")
	}
	for binaryCtx.arrBuf.HasNext() {
		var elMagicBytes byte

		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(1)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read MagicBytes")
		}
		elMagicBytes = conv.ConvertBytesToByte(binaryCtx.buf)

		o.MagicBytes = append(o.MagicBytes, elMagicBytes)

	}

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray")
	}
	for binaryCtx.arrBuf.HasNext() {
		var elMagicObjectArray ReverseCommonObject

		o.MagicObjectArray = append(o.MagicObjectArray, elMagicObjectArray)

	}

	return nil
}

type ReverseMagicStringResponse struct {
	ReversedMagicString string
	MagicInt8           int8
	MagicInt16          int16
	MagicInt32          int32
	MagicInt64          int64
	MagicUInt8          uint8
	MagicUInt16         uint16
	MagicUInt32         uint32
	MagicUInt64         uint64
	MagicBool           bool
	MagicBytes          []byte
	MagicObject         ReverseCommonObject
	MagicObjectArray    []ReverseCommonObject
}

var _ message.Message = (*ReverseMagicStringResponse)(nil)

func (o *ReverseMagicStringResponse) Marshal() []byte {
	var (
		arrBuf []byte
		b      = make([]byte, 0, 208)
	)

	size := conv.ConvertSizeToBytes(0)
	b = append(b, size...)
	b = append(b, conv.ConvertSizeToBytes(len([]byte(o.ReversedMagicString)))...)
	b = append(b, conv.ConvertStringToBytes(o.ReversedMagicString)...)
	b = append(b, conv.ConvertInt8ToBytes(o.MagicInt8)...)
	b = append(b, conv.ConvertInt16ToBytes(o.MagicInt16)...)
	b = append(b, conv.ConvertInt32ToBytes(o.MagicInt32)...)
	b = append(b, conv.ConvertInt64ToBytes(o.MagicInt64)...)
	b = append(b, conv.ConvertUint8ToBytes(o.MagicUInt8)...)
	b = append(b, conv.ConvertUint16ToBytes(o.MagicUInt16)...)
	b = append(b, conv.ConvertUint32ToBytes(o.MagicUInt32)...)
	b = append(b, conv.ConvertUint64ToBytes(o.MagicUInt64)...)
	b = append(b, conv.ConvertBoolToBytes(o.MagicBool)...)
	arrBuf = make([]byte, 0, 128)
	for _, elMagicBytes := range o.MagicBytes {
		arrBuf = append(arrBuf, conv.ConvertByteToBytes(elMagicBytes)...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBuf))...)
	b = append(b, arrBuf...)
	b = append(b, o.MagicObject.Marshal()...)
	arrBuf = make([]byte, 0, 128)
	for _, elMagicObjectArray := range o.MagicObjectArray {
		arrBuf = append(arrBuf, elMagicObjectArray.Marshal()...)
	}
	b = append(b, conv.ConvertSizeToBytes(len(arrBuf))...)
	b = append(b, arrBuf...)

	size = conv.ConvertSizeToBytes(len(b) - len(size))
	for i := 0; i < len(size); i++ {
		b[i] = size[i]
	}

	return b
}

func (o *ReverseMagicStringResponse) Unmarshal(b *conv.BinaryIterator) error {
	binaryCtx := struct {
		err                error
		size, arrSize, pos int
		buf, arrBuf        *conv.BinaryIterator
	}{}

	binaryCtx.err = nil

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read ReversedMagicString size")
	}
	binaryCtx.buf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read ReversedMagicString")
	}
	o.ReversedMagicString = conv.ConvertBytesToString(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt8")
	}
	o.MagicInt8 = conv.ConvertBytesToInt8(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(2)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt16")
	}
	o.MagicInt16 = conv.ConvertBytesToInt16(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(4)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt32")
	}
	o.MagicInt32 = conv.ConvertBytesToInt32(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(8)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicInt64")
	}
	o.MagicInt64 = conv.ConvertBytesToInt64(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt8")
	}
	o.MagicUInt8 = conv.ConvertBytesToUint8(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(2)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt16")
	}
	o.MagicUInt16 = conv.ConvertBytesToUint16(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(4)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt32")
	}
	o.MagicUInt32 = conv.ConvertBytesToUint32(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(8)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicUInt64")
	}
	o.MagicUInt64 = conv.ConvertBytesToUint64(binaryCtx.buf)

	binaryCtx.buf, binaryCtx.err = b.Slice(1)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBool")
	}
	o.MagicBool = conv.ConvertBytesToBool(binaryCtx.buf)

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBytes size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicBytes")
	}
	for binaryCtx.arrBuf.HasNext() {
		var elMagicBytes byte

		binaryCtx.buf, binaryCtx.err = binaryCtx.arrBuf.Slice(1)
		if binaryCtx.err != nil {
			return errors.Wrap(binaryCtx.err, "failed to read MagicBytes")
		}
		elMagicBytes = conv.ConvertBytesToByte(binaryCtx.buf)

		o.MagicBytes = append(o.MagicBytes, elMagicBytes)

	}

	binaryCtx.size, binaryCtx.err = b.NextSize()
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray size")
	}
	binaryCtx.arrBuf, binaryCtx.err = b.Slice(binaryCtx.size)
	if binaryCtx.err != nil {
		return errors.Wrap(binaryCtx.err, "failed to read MagicObjectArray")
	}
	for binaryCtx.arrBuf.HasNext() {
		var elMagicObjectArray ReverseCommonObject

		o.MagicObjectArray = append(o.MagicObjectArray, elMagicObjectArray)

	}

	return nil
}
func GetHandlers(reverse Reverse) map[hash.HandlerHash]*server.Handler {
	handlers := make(map[hash.HandlerHash]*server.Handler)

	var callFuncReverseMagicString server.HandlerFunc
	if reverse != nil {
		callFuncReverseMagicString = ReverseMagicStringSqueeze(reverse.ReverseMagicString)
	}

	handlers[hash.HandlerHash{0x52, 0x65, 0x76, 065}] = &server.Handler{
		CallFuncHandler: callFuncReverseMagicString,
		HandlerType:     server.HandlerT,
		RequestMsgType:  &ReverseMagicStringRequest{},
		ResponseMsgType: &ReverseMagicStringResponse{},
		Tags:            tagsByHandlerName["ReverseMagicString"],
	}

	return handlers
}

func GetEmptyHandlers() map[hash.HandlerHash]*server.Handler {
	handlers := make(map[hash.HandlerHash]*server.Handler)

	handlers[hash.HandlerHash{0x52, 0x65, 0x76, 065}] = &server.Handler{
		HandlerType:     server.HandlerT,
		RequestMsgType:  &ReverseMagicStringRequest{},
		ResponseMsgType: &ReverseMagicStringResponse{},
	}

	return handlers
}

func NewServer(cfg *server.Config, logger *zap.Logger, reverse Reverse) *server.Server {
	handlers := GetHandlers(reverse)

	return server.NewServer(cfg, logger, handlers)
}

func CallClientMethod(ctx context.Context, host string, port int, serviceName string, methodName string, req message.Message) (message.Message, error) {
	if serviceName == "Reverse" {
		if methodName == "ReverseMagicString" {
			client, err := NewClientReverse(host, port)
			if err != nil {
				return nil, err
			}
			return client.ReverseMagicString(ctx, req.(*ReverseMagicStringRequest))
		}
	}

	return nil, errors.New("unknown service or method")
}

type ClientReverse struct {
	peer *peer.Peer
}

func NewClientReverse(host string, port int) (*ClientReverse, error) {
	conn, err := net.Dial("tcp", host+":"+strconv.Itoa(port))
	if err != nil {
		return nil, err
	}
	conn, err = transport.ServerHandshake(conn)
	if err != nil {
		return nil, err
	}
	securedPeer := peer.NewPeer(conn)
	client := &ClientReverse{peer: securedPeer}
	return client, nil
}

func (c *ClientReverse) ReverseMagicString(ctx context.Context, req *ReverseMagicStringRequest) (*ReverseMagicStringResponse, error) {
	err := c.peer.WriteResponse(hash.HandlerHash{0x52, 0x65, 0x76, 065}, req)

	msg := make([]byte, 0, 1024)

	for {
		buf := make([]byte, 1024)
		n, err := c.peer.Read(buf)
		if err != nil {
			return nil, err
		}

		if n == 0 {
			break
		}

		if n < len(buf) {
			buf = buf[:n]
			msg = append(msg, buf...)
			break
		}

		msg = append(msg, buf...)
	}

	_, _, offset, err := conv.GetHandler(msg)
	if err != nil {
		return nil, err
	}

	respMsg := &ReverseMagicStringResponse{}

	err = respMsg.Unmarshal(conv.NewBinaryIterator(msg[offset:]))
	if err != nil {
		return nil, err
	}

	return respMsg, nil
}
